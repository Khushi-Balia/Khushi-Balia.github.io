<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://khushi-balia.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://khushi-balia.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-10-22T17:37:03+00:00</updated><id>https://khushi-balia.github.io/feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">My Google Summer of Code Experience- A Journey of Learning, Growth, and Contribution</title><link href="https://khushi-balia.github.io/blog/2023/final-report/" rel="alternate" type="text/html" title="My Google Summer of Code Experience- A Journey of Learning, Growth, and Contribution" /><published>2023-10-21T19:53:00+00:00</published><updated>2023-10-21T19:53:00+00:00</updated><id>https://khushi-balia.github.io/blog/2023/final-report</id><content type="html" xml:base="https://khushi-balia.github.io/blog/2023/final-report/"><![CDATA[<p>As I sit here on the eve of my Google Summer of Code project submission deadline, I can’t help but reflect on the incredible journey I’ve been on over the past few months. When I first applied to GSoC, I was motivated by the opportunity to work on a real-world open source project and to gain valuable experience. I was also eager to learn from and collaborate with other talented developers from around the world.</p>

<p>I was thrilled to be accepted into the program and to be given the opportunity to work on the <code class="language-plaintext highlighter-rouge">Building an LLVM Backend for PRU</code> project under <code class="language-plaintext highlighter-rouge">Beagleboard.org</code>.</p>

<p>Image</p>

<p>As I embarked on my Google Summer of Code project of Building an LLVM backend for PRU, I was filled with both excitement and apprehension. The prospect of working on such a widely used and respected compiler infrastructure was exhilarating, but the task of navigating the vast and unexplored territory of the LLVM codebase loomed large.</p>

<p>The initial stages of the project were indeed challenging. The LLVM codebase is immense, with thousands of lines of code spread across countless files and directories. Documentation, while present, was often sparse or outdated. As I delved deeper into the labyrinthine depths of the code, I found myself frequently lost. But I persevered, fueled by my determination to succeed and complete the project.</p>

<p>Gradually, I began to make progress. I started to understand the overall structure of the LLVM codebase and to identify the key components that would be involved in building a new backend. I also began to develop a deeper understanding of the various stages of the compilation process.</p>

<p>As the weeks turned into months, I slowly but surely made progress on the tasks. There were <strong>three main milestones</strong> of the project.</p>

<h4 id="1-understanding-the-cpu0-backend-tutorial-and-implementing-it">1. Understanding the Cpu0 backend tutorial and implementing it</h4>

<p>The first milestone of the project was to understand and implement the Cpu0 backend tutorial. This tutorial provides a step-by-step guide to building a new LLVM backend. By following the tutorial, I was able to gain a deep understanding of the LLVM backend architecture.</p>

<p>The Cpu0 backend tutorial was originally developed for <strong>LLVM version 3.1</strong>. Since then, the LLVM codebase has undergone a number of significant changes. As a result, the tutorial was not directly compatible with the newer LLVM versions.</p>

<p>In order to use the tutorial as a starting point for my project, I had to make a number of modifications to the code.</p>

<p>You can find the steps of building the Cpu0 backend in <a href="https://khushi-balia.github.io/blog/2023/week-2/">this blog</a> of mine.</p>

<h4 id="2-new-backend-initialization-for-pru">2. New backend initialization for PRU</h4>

<p>The second milestone of the project was to implement the necessary infrastructure for supporting the PRU target. This involved registering PRU as a target with <strong>LLVM version 16</strong> (the latest version)</p>

<p>One of the key tasks involved in registering PRU as a target was to create a new Target class for PRU. This class is responsible for providing LLVM with information about the PRU architecture, such as the instruction set, register set and so on.</p>

<p>Directory structure for PRU LLVM backend for <strong>milestone 2</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lib/TargetPRU/                                                                                                
├── CMakeLists.txt
├── MCTargetDesc/
│   ├── PRUInstPrinter.cpp
│   ├── PRUMCAsmInfo.cpp
│   ├── PRUMCCodeEmitter.cpp
│   ├── PRUMCCodeEmitter.h
│   ├── PRUMCTargetDesc.cpp
│   ├── PRUMCTargetDesc.h
│   └── PRUTargetStreamer.cpp
│   └── PRUTargetStreamer.h
├── TargetInfo/
│   ├── PRUTargetInfo.cpp
│   ├── PRUTargetInfo.h
│   └── CMakeLists.txt
├── PRU.h
├── PRU.td
├── PRUAsmPrinter.cpp
├── PRUCallingConv.td
├── PRUFrameLowering.cpp
├── PRUFrameLowering.h
├── PRUISelDAGToDAG.cpp
├── PRUISelLowering.cpp
├── PRUISelLowering.h
├── PRUInstrFormats.td
├── PRUInstrInfo.cpp
├── PRUInstrInfo.h
├── PRUInstrInfo.td
├── PRUMachineFunctionInfo.cpp
├── PRUMachineFunctionInfo.h
├── PRURegisterInfo.cpp
├── PRURegisterInfo.h
├── PRURegisterInfo.td
├── PRUSelectionDAGInfo.h
├── PRUSubtarget.cpp
├── PRUSubtarget.h
└── PRUTargetMachine.cpp
└── PRUTargetMachine.h
</code></pre></div></div>
<p>By implementing dummy code for the above, I was able to successfully register PRU as a target with LLVM version 16. This was a critical step in the development of the new PRU backend.</p>

<p>Image</p>

<h4 id="3-adding-code-for-pru-assembly-code-generation">3. Adding code for PRU assembly code generation</h4>

<p>The third and final milestone of the project was to add code to the backend for PRU assembly code generation. Originally, the plan was to implement this milestone using LLVM version 16. However, due to the very limited to no documentation available for the changes in LLVM 16, it was decided to implement it in LLVM 8 instead.</p>

<p>This decision ultimately proved to be the right one. By using LLVM 8, I was able to take advantage of the well-documented resources, which made it easier to develop a functional backend for the PRU architecture.</p>

<p>Directory structure for PRU LLVM backend for <strong>milestone 3</strong>, added files to the milestone 2 codebase.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lib/Target/PRU/
├── CMakeLists.txt
├── InstPrinter/
│   ├── CMakeLists.txt
│   ├── PRUInstPrinter.cpp
│   └── PRUInstPrinter.h
├── LLVMBuild.txt
├── MCTargetDesc/
│   ├── CMakeLists.txt
│   ├── PRUAsmBackend.cpp
│   ├── PRUELFObjectWriter.cpp
│   ├── PRUFixupKinds.h
│   ├── PRUMCAsmInfo.cpp
│   ├── PRUMCAsmInfo.h
│   ├── PRUMCCodeEmitter.cpp
│   ├── PRUMCTargetDesc.cpp
│   └── PRUMCTargetDesc.h
├── PRU.h
├── PRU.td
├── PRUAsmPrinter.cpp
├── PRUCallingConv.td
├── PRUFrameLowering.cpp
├── PRUFrameLowering.h
├── PRUISelDAGToDAG.cpp
├── PRUISelLowering.cpp
├── PRUISelLowering.h
├── PRUInstrFormats.td
├── PRUInstrInfo.cpp
├── PRUInstrInfo.h
├── PRUInstrInfo.td
├── PRUMCInstLower.cpp
├── PRUMCInstLower.h
├── PRUMachineFunctionInfo.cpp
├── PRUMachineFunctionInfo.h
├── PRURegisterInfo.cpp
├── PRURegisterInfo.h
├── PRURegisterInfo.td
├── PRUSubtarget.cpp
├── PRUSubtarget.h
└── PRUTargetMachine.cpp
└── PRUTargetMachine.h
</code></pre></div></div>

<p>Image</p>

<h4 id="workflow-for-milestone-2-and-milestone-3">Workflow for Milestone 2 and Milestone 3:</h4>

<h5 id="tablegen-description-files">TableGen description files</h5>

<p>In order to implement a backend, I needed to write description files related to the target, that are called .td files. These .td files are translated into C++ source code by TableGen’s tool llvm-tblgen when building the compiler. The generated code is then used in the backend implementation.</p>

<p>After the .td file is processed, some .inc files are generated under lib/Target/PRU/ in the build path. These .inc files are included in the backend implementation. The generated specification is what I specified in CMakeLists.txt.</p>

<p>There are multiple .td files, divided into categories to describe various information of the target platform, such as register information, instruction information, calling convention etc.</p>

<p>In order to implement a backend, I needed to write description files related to the target, that are called .td files. These .td files are translated into C++ source code by TableGen’s tool llvm-tblgen when building the compiler. The generated code is then used in the backend implementation.</p>

<p>After the .td file is processed, some .inc files are generated under lib/Target/PRU/ in the build path. These .inc files are included in the backend implementation. The generated specification is what I specified in CMakeLists.txt.</p>

<p>There are multiple .td files, divided into categories to describe various information of the target platform, such as register information, instruction information, calling convention etc.</p>

<ul>
  <li><strong>PRU.td</strong> - This is the top level entry point for the PRU target</li>
</ul>

<p>This file currently contains several other .td files, and then defines a subclass PRU based on the Target class.</p>

<ul>
  <li><strong>PRURegisterInfo.td</strong> - Register Information</li>
</ul>

<p>All registers and register sets (RegisterClass) are defined in this file. The class PRUReg inherits from the class RegisterWithSubRegs.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class PRUReg&lt;bits&lt;16&gt; num, string name, list&lt;Register&gt; subregs = [], list&lt;string&gt; altNames = []&gt; : RegisterWithSubRegs&lt;name, subregs&gt;  
</code></pre></div></div>

<ul>
  <li><strong>PRUCallingConv.td</strong> - Calling Conventions</li>
</ul>

<p>The calling convention definitions describe the part of the ABI which controls how data moves between function calls.</p>

<ul>
  <li><strong>PRUInstrFormats.td</strong> - PRU Instruction formats</li>
</ul>

<p>This file describes the patterns for definitions of target-specific instructions. The highest-level class InstPRU of the PRU instruction inherits from the Instruction class.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class InstPRU&lt;dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern&gt;
	: Instruction { … }
</code></pre></div></div>

<p>In addition, because the instructions of PRU are divided into more categories, those subcategories inherit from the InstPRU class.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ALU_Inst_RR&lt;bits&lt;3&gt; opcode, bits&lt;4&gt; instopcode, dag outs, dag ins, string asmstr,
              	list&lt;dag&gt; pattern&gt;
	: InstPRU&lt;outs, ins, asmstr, pattern&gt; { … }
</code></pre></div></div>

<ul>
  <li><strong>PRUInstrInfo.td</strong> - Complete PRU Instruction Definitions</li>
</ul>

<p>The complete instruction definitions inherit from the instruction format classes to complete the TableGen Instruction base class. The multiclass functionality makes it easier to define multiple instructions that are very similar to each other. For example, the register-register (rr) and register-immediate (ri) ALU instructions are defined within the multiclass. It also contains some SDNode node definitions as well as operand type definitions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def PRUcallseq_start :
             	SDNode&lt;"ISD::CALLSEQ_START", SDT_PRUCallSeqStart,
                    	[SDNPHasChain, SDNPOutGlue]&gt;;
</code></pre></div></div>

<h5 id="target-registration">Target registration</h5>

<p>Once the necessary TableGen description files were written, the next step was to register the new target PRU with LLVM. The following things were done:</p>

<ul>
  <li>
    <p>I created a <strong>PRU.h</strong> file under the PRU path. This file includes a number of other header files that are needed by the PRU backend.</p>
  </li>
  <li>
    <p>I then created the <strong>PRUTargetMachine.cpp</strong> file and the corresponding header file. The PRUTargetMachine class is responsible for providing LLVM with information about the PRU target. It has the <code class="language-plaintext highlighter-rouge">LLVMInitializePRUTarget()</code> function.</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern "C"  void LLVMInitializePRUTarget() {
    RegisterTargetMachine&lt;PRUTargetMachine&gt; X(getThePRUTarget());
}
</code></pre></div></div>

<ul>
  <li>I then created a subdirectory <strong>lib/Target/PRU/TargetInfo/</strong>, and created PRUTargetInfo.cpp under this path. In this file, I called the RegisterTarget interface to register my PRU target.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        extern "C" void LLVMInitializePRUTargetInfo() {
       RegisterTarget&lt;Triple::pru&gt; X(getThePRUTarget(), "pru", "PRU microcontroller");
         }
</code></pre></div></div>

<ul>
  <li>I also created a subdirectory <strong>lib/Target/PRU/MCTargetDesc/</strong>, and created a new MCTargetDesc.cpp file and its corresponding header file in this path. Here, a function <code class="language-plaintext highlighter-rouge">LLVMInitializePRUTargetMC()</code> is written. The MCTargetDesc class is responsible for providing LLVM with information about the PRU target’s machine code.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern "C" void LLVMInitializePRUTargetMC() {     
    RegisterMCAsmInfo X(getThePRUTarget(), createPRUMCAsmInfo);  TargetRegistry::RegisterMCInstrInfo(getThePRUTarget(), createPRUMCInstrInfo);  TargetRegistry::RegisterMCRegInfo(getThePRUTarget(), createPRUMCRegisterInfo);  TargetRegistry::RegisterMCAsmBackend(getThePRUTarget(), createPRUAsmBackend);  TargetRegistry::RegisterMCCodeEmitter(getThePRUTarget(), createPRUMCCodeEmitter);  TargetRegistry::RegisterMCInstPrinter(getThePRUTarget(), createPRUMCInstPrinter);
}
</code></pre></div></div>

<p>The PRUTargetInfo class calls the RegisterTarget method to register the PRU target with LLVM. The RegisterTarget method is defined in the TargetInfo class.
The MCTargetDesc class provides LLVM with information about the PRU target’s machine code. This information is used by LLVM to generate code for the PRU target.
These were the main things done for milestone 2.</p>

<h4 id="the-work-for-milestone-3-was-divided-into-3-tasks">The work for milestone 3 was divided into 3 tasks:</h4>

<h4 id="1-laying-the-foundations---pru-target-machine-architecture">1. Laying the Foundations - PRU Target Machine Architecture</h4>

<p>In this task, I created/ modified a number of files to implement the target machine architecture for PRU. These files include:</p>

<ul>
  <li>
    <p><strong>PRUTargetMachine.h/.cpp</strong>: These files define the essential class for the target machine architecture: PRUTargetMachine. This class inherits from LLVMTargetMachine and handles initialization tasks like DataLayout, relocation mod. The pivotal <code class="language-plaintext highlighter-rouge">getSubtargetImpl()</code> function constructs a Subtarget object, setting the stage for further architectural components.</p>
  </li>
  <li>
    <p><strong>PRUFrameLowering.h/.cpp</strong>: This section focuses on Frame Lowering, critical for stack management. The PRUFrameLowering class inherits from TargetFrameLowering. It deals with the stack and manages various contents, including function parameters, registers, and more. The <code class="language-plaintext highlighter-rouge">hasFP()</code> method helps identify the presence of a Frame Pointer.</p>
  </li>
  <li>
    <p><strong>PRUInstrInfo.h/.cpp</strong>: These files handle instruction-related actions, building upon the instruction descriptions generated by tablegen. The PRUInstrInfo class, inherited from PRUGenInstrInfo, contains critical elements, including the Subtarget object, which is initialised in the constructor.</p>
  </li>
  <li>
    <p><strong>PRUISelLowering.h/.cpp</strong>: This file defines the interfaces that PRU uses to lower LLVM code into a selection DAG. Here, the PRUTargetLowering class is defined and inherited from TargetLowering. It integrates the PRUGenCallingConv.inc file, generated from PRUCallingConv.td, and provides methods like <code class="language-plaintext highlighter-rouge">LowerGlobalAddress()</code>,<code class="language-plaintext highlighter-rouge">LowerReturn()</code>, <code class="language-plaintext highlighter-rouge">LowerFormalArguments()</code> - transforms physical registers into virtual registers</p>
  </li>
  <li>
    <p><strong>PRUMachineFunctionInfo.h/.cpp</strong>: Handling actions related to functions, the PRUMachineFunctionInfo class inherits the MachineFunctionInfo class. It declares methods related to parameters, currently serving as placeholders.</p>
  </li>
  <li>
    <p><strong>PRURegisterInfo.h/.cpp</strong>: These files contain the PRUGenRegisterInfo.inc file, which defines the PRURegisterInfo based on PRUGenRegisterInfo. Several register-related methods are defined.</p>
  </li>
  <li>
    <p><strong>PRUSubtarget.h/.cpp</strong>: This class, inherited from PRUGenSubtargetInfo, defines the PRUSubtarget. It maintains properties and establishes interfaces with other classes like <code class="language-plaintext highlighter-rouge">getInstrInfo()</code> and <code class="language-plaintext highlighter-rouge">getRegisterInfo()</code></p>
  </li>
</ul>

<p>Completing Task 1 involved setting the stage for the entire PRU target machine architecture, from instruction handling to function management. These files form the cornerstone upon which subsequent development tasks will build.</p>

<h4 id="2-adding-asmprinter-support">2. Adding AsmPrinter Support</h4>

<p>With the groundwork laid, I added AsmPrinter support, a crucial component in code generation. This task focuses on turning Machine DAGs into assembly code through the following steps:</p>

<ul>
  <li>
    <p><strong>InstPrinter/PRUInstPrinter.h/.cpp</strong>: These files introduce the InstPrinter module, primarily responsible for outputting MCInst to assembly files. The PRUInstPrinter class inherits from MCInstPrinter and includes the crucial <code class="language-plaintext highlighter-rouge">printInstruction()</code> function, generated by tblgen based on PRUInstrInfo.td. Additionally, <code class="language-plaintext highlighter-rouge">getRegisterName()</code> and various internal functions aid in outputting instructions.</p>
  </li>
  <li>
    <p><strong>PRUMCInstLower.h/.cpp</strong>: These files handle the lowering of MI (Machine Instruction) to MCInst (Machine Code Instruction). The PRUMCInstLower class is defined, with its primary member function, <code class="language-plaintext highlighter-rouge">Lower()</code>, converting MI to MCInst. This step involves setting the Opcode and Operand list.</p>
  </li>
  <li>
    <p><strong>MCTargetDesc/PRUMCAsmInfo.h/.cpp</strong>: These files introduce the PRUMCAsmInfo class, inherited from MCAsmInfoELF. Although relatively simple, it defines some assembly file format specifics.</p>
  </li>
  <li>
    <p><strong>PRUAsmPrinter.h/.cpp</strong>: The PRUAsmPrinter class serves as the entry point for outputting MI-structured programs to assembly files. This class is inherited from AsmPrinter and implements various <code class="language-plaintext highlighter-rouge">Emit</code> functions for emitting different content. The AsmPrinter differs from the InstPrinter in that it emits MI to a file and handles additional information like debugging and file descriptions.</p>
  </li>
</ul>

<p>Task 2 enriches the PRU target machine architecture by enabling it to produce assembly output, a fundamental step in the code generation process.</p>

<h4 id="implementing-dagtodagisel---bridging-llvm-ir-to-machine-dag">Implementing DAGToDAGISel - Bridging LLVM IR to Machine DAG</h4>

<p>Task 3 marks a pivotal phase in developing the PRU target machine architecture. It focuses on extending support for DAGToDAGISel, a critical component responsible for converting LLVM IR DAG (Directed Acyclic Graph) to the Machine DAG. This process is essential for ensuring that the high-level LLVM IR code can be transformed into low-level machine code instructions.</p>

<ul>
  <li>
    <p><strong>PRUISelDAGToDAG.cpp</strong>: This file plays a central role in the implementation of DAGToDAGISel for the PRU architecture. The <code class="language-plaintext highlighter-rouge">PRUDAGToDAGISel</code> class is defined here, inheriting from the <code class="language-plaintext highlighter-rouge">SelectionDAGISel</code> class. It provides several key interfaces and functions:</p>

    <ul>
      <li>
        <p><em>Select</em>: The Select function serves as the entry point for instruction selection. It is used for initial attempts at selecting instructions.</p>
      </li>
      <li>
        <p><em>SelectCode</em>: If the initial selection in the Select function doesn’t result in a valid instruction, the process proceeds to the SelectCode function. The SelectCode function is defined in the <code class="language-plaintext highlighter-rouge">PRUGenDAGISel.inc</code> file, generated by tablegen. It attempts to select a valid instruction based on the patterns specified in the target description (td) files.</p>
      </li>
      <li>
        <p><em>SelectAddr</em>: The SelectAddr function is responsible for selecting the execution of address modes. Since some nodes in the IR DAG represent complex address operands, this function handles their selection. The target description (td) files can describe specific patterns for address operands, and these patterns are left for the SelectAddr function to process.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>PRUTargetMachine.cpp</strong>: In this file, a directive selector for DAG selection is registered. The PRUSEISelDAG class is added as part of this registration process. The <code class="language-plaintext highlighter-rouge">addInstSelector()</code> method, which overrides a method in the parent class <code class="language-plaintext highlighter-rouge">TargetPassConfig</code>, ensures that DAG instruction selection for PRU is supported.</p>
  </li>
</ul>

<p>Task 3 completes the critical chain that allows LLVM to translate high-level LLVM IR code into machine-level instructions. It encompasses instruction selection, handling complex address operands, and ensuring that the generated machine code adheres to the PRU target architecture.</p>

<h3 id="project-details">Project Details:</h3>

<h4 id="project-name">Project Name:</h4>
<h4 id="mentors">Mentors:</h4>
<h4 id="code">Code:</h4>
<h4 id="introductory-video">Introductory Video:</h4>
<h4 id="proposal">Proposal:</h4>

<h3 id="conclusion">Conclusion</h3>]]></content><author><name></name></author><summary type="html"><![CDATA[Final Report]]></summary></entry><entry><title type="html">Writing Tablegen files for PRU target</title><link href="https://khushi-balia.github.io/blog/2023/week-4/" rel="alternate" type="text/html" title="Writing Tablegen files for PRU target" /><published>2023-06-30T19:53:00+00:00</published><updated>2023-06-30T19:53:00+00:00</updated><id>https://khushi-balia.github.io/blog/2023/week-4</id><content type="html" xml:base="https://khushi-balia.github.io/blog/2023/week-4/"><![CDATA[<p>The LLVM project provides a powerful infrastructure for compiler development, enabling the creation of efficient and optimized code for various target architectures. To harness the full potential of LLVM, developers often need to provide accurate and detailed information about the target hardware. Two essential components in this process are the TableGen files for Register Info and Instruction Info.</p>

<p><code class="language-plaintext highlighter-rouge">TableGen</code> is necessary for writing the abstract target description. This tool translates a target description file (.td) into C++ code that is used in code generation. Its main goal is to reduce large, tedious descriptions into smaller and flexible definitions that are easier to manage and structure.
 The idea is that TableGen is a maintainable and human-readable description which is translated into C++ by the tablegen tool and compiled, along with the hand-coded C++ files from your backend, when building LLVM.</p>

<p>In this blog post, we will explore the process of writing a TableGen file for PRU’s Register Info</p>

<h5 id="understanding-register-info">Understanding Register Info:</h5>

<p>Register Info files in LLVM provide crucial information about the target hardware’s register set. This includes the number of registers, their names, allocation order, register classes, and more. By accurately defining the register information, LLVM can generate optimized machine code specific to the target architecture.</p>

<p>Register fields in the PRU AM335x architecture:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">REG, REG1, REG2, ... (8 to 32 bits)</code>:
The PRU AM335x architecture supports multiple general-purpose registers, denoted as REG, REG1, REG2, and so on. These registers can hold values ranging from 8 to 32 bits. They are commonly used for general-purpose calculations and data manipulation. Examples of such registers include r0, r1, r2, etc.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Rn, Rn1, Rn2, ... (32-bit register fields)</code>:
The PRU AM335x architecture provides a set of 32-bit registers, denoted as Rn, Rn1, Rn2, and so forth. These registers span from r0 to r31, offering a wider range of storage for larger data types or calculations.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Rn.bx (byte field)</code>:
The PRU AM335x architecture includes byte fields specified as Rn.bx. These byte fields allow for the selection of a specific byte within a register. The ‘x’ in Rn.bx can take values from 0 to 3, representing the four available bytes in the register. Examples include r0.b0 (byte 0 of register r0) or r0.b3 (byte 3 of register r0).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Rn.wx (two-byte field - word)</code>:
To handle two-byte (word) fields, the PRU AM335x architecture introduces Rn.wx notation. The ‘x’ in Rn.wx can take values from 0 to 2, representing the three possible word spans. A word spans two bytes, and each value of ‘x’ denotes the starting byte of the word. Examples include r0.w0 (word spanning bytes 0 and 1), r0.w1 (word spanning bytes 1 and 2), and so on.</p>
  </li>
</ul>

<h5 id="pru-register-info-tablegen-file">PRU Register Info tablegen file</h5>

<p>At the top of the file we find the following class:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">PRUReg</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">,</span> <span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">Register</span><span class="o">&gt;</span> <span class="n">subregs</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">altNames</span> <span class="o">=</span> <span class="p">[]</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">RegisterWithSubRegs</span><span class="o">&lt;</span><span class="n">name</span><span class="p">,</span> <span class="n">subregs</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">field</span> <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">Num</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
 
  <span class="n">let</span> <span class="n">HWEncoding</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s">"PRU"</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">SubRegs</span> <span class="o">=</span> <span class="n">subregs</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">AltNames</span> <span class="o">=</span> <span class="n">altNames</span><span class="p">;</span>
<span class="p">}</span>  

</code></pre></div></div>

<p>That code declares a class PRUReg that inherits from the internalized Register class which is defined in include/llvm/Target/Target.td. The code is also telling us that we must provide up to four arguments when inheriting from this class, the last 2 are optional.</p>

<p>Moving on, we find the following register definitions in the file. Each line of code is a TableGen record that defines a single register.</p>

<p>Since we know, the registers can be byte field, two-byte field(word), 32-bit register, we need to define all of these.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">//// 8 bit subregs</span>
 <span class="n">def</span> <span class="n">r0_b0</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">"r0.b0"</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r0_b1</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">"r0.b1"</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r0_b2</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">"r0.b2"</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r0_b3</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">"r0.b3"</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r1_b0</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">"r1.b0"</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r1_b1</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">"r1.b1"</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r1_b2</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">"r1.b2"</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r1_b3</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">"r1.b3"</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="p">.....</span>

 <span class="c1">//// 16 bit subregs</span>
 <span class="n">def</span> <span class="n">r0_w0</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">"r0.w0"</span><span class="p">,</span> <span class="p">[</span><span class="n">r0_b0</span><span class="p">,</span> <span class="n">r0_b1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r0_w2</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">"r0.w2"</span><span class="p">,</span> <span class="p">[</span><span class="n">r0_b2</span><span class="p">,</span> <span class="n">r0_b3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r0_w1</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">"r0.w1"</span><span class="p">,</span> <span class="p">[</span><span class="n">r0_b1</span><span class="p">,</span> <span class="n">r0_b2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r1_w0</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">"r1.w0"</span><span class="p">,</span> <span class="p">[</span><span class="n">r1_b0</span><span class="p">,</span> <span class="n">r1_b1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r1_w2</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">"r1.w2"</span><span class="p">,</span> <span class="p">[</span><span class="n">r1_b2</span><span class="p">,</span> <span class="n">r1_b3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r1_w1</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">"r1.w1"</span><span class="p">,</span> <span class="p">[</span><span class="n">r1_b1</span><span class="p">,</span> <span class="n">r1_b2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="p">.....</span>

 <span class="c1">//// 32 bit main regs</span>
 <span class="n">def</span> <span class="n">r0</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="s">"r0"</span><span class="p">,</span> <span class="p">[</span><span class="n">r0_w0</span><span class="p">,</span> <span class="n">r0_w2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r1</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="s">"r1"</span><span class="p">,</span> <span class="p">[</span><span class="n">r1_w0</span><span class="p">,</span> <span class="n">r1_w2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r2</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="s">"r2"</span><span class="p">,</span> <span class="p">[</span><span class="n">r2_w0</span><span class="p">,</span> <span class="n">r2_w2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r3</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="s">"r3"</span><span class="p">,</span> <span class="p">[</span><span class="n">r2_w0</span><span class="p">,</span> <span class="n">r3_w2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r4</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="s">"r4"</span><span class="p">,</span> <span class="p">[</span><span class="n">r4_w0</span><span class="p">,</span> <span class="n">r4_w2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
 <span class="n">def</span> <span class="n">r5</span> <span class="o">:</span> <span class="n">PRUReg</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span> <span class="s">"r5"</span><span class="p">,</span> <span class="p">[</span><span class="n">r5_w0</span><span class="p">,</span> <span class="n">r5_w2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

</code></pre></div></div>

<p>The records inherit from two classes: PRUReg (that we already discussed) and DwarfRegNum. DwarfRegNum is yet another internalized class defined used to provide debug information for GCC and GDB.</p>

<p>The last few lines in the file define the Register Classes.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">def</span> <span class="n">breg</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">"PRU"</span><span class="p">,</span> <span class="p">[</span><span class="n">i8</span><span class="p">],</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span> <span class="s">"b%u"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

 <span class="n">def</span> <span class="n">reg8</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">"PRU"</span><span class="p">,</span> <span class="p">[</span><span class="n">i8</span><span class="p">],</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
    <span class="p">(</span><span class="n">sequence</span> <span class="s">"r%u_b0"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span>
    <span class="p">(</span><span class="n">sequence</span> <span class="s">"r%u_b1"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span>
    <span class="p">(</span><span class="n">sequence</span> <span class="s">"r%u_b2"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span>
    <span class="p">(</span><span class="n">sequence</span> <span class="s">"r%u_b3"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>
 <span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

 <span class="n">def</span> <span class="n">reg16</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">"PRU"</span><span class="p">,</span> <span class="p">[</span><span class="n">i16</span><span class="p">],</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
    <span class="p">(</span><span class="n">sequence</span> <span class="s">"r%u_w0"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span>
    <span class="p">(</span><span class="n">sequence</span> <span class="s">"r%u_w1"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span>
    <span class="p">(</span><span class="n">sequence</span> <span class="s">"r%u_w2"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>
 <span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

 <span class="n">def</span> <span class="n">reg32</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">"PRU"</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="n">sequence</span> <span class="s">"r%u"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[Week 3-4]]></summary></entry><entry><title type="html">Implementing the Cpu0 Backend</title><link href="https://khushi-balia.github.io/blog/2023/week-2/" rel="alternate" type="text/html" title="Implementing the Cpu0 Backend" /><published>2023-06-14T19:53:00+00:00</published><updated>2023-06-14T19:53:00+00:00</updated><id>https://khushi-balia.github.io/blog/2023/week-2</id><content type="html" xml:base="https://khushi-balia.github.io/blog/2023/week-2/"><![CDATA[<p>LLVM is a widely used open-source compiler infrastructure that provides a set of modular and reusable compiler and toolchain technologies. One of the key strengths of LLVM is its extensibility, allowing developers to add support for new architectures by building backend targets. In this blog, we will walk you through the process of building the Cpu0 backend in LLVM, enabling you to generate code for the Cpu0 architecture. Let’s get started!</p>

<h5 id="the-cpu0-backend">The Cpu0 Backend</h5>

<p>Cpu0 is a 32-bit architecture. This is the reference of the Cpu0 backend in LLVM
<a href="https://jonathan2251.github.io/lbd/llvmstructure.html">Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</a></p>

<blockquote class="block-warning">
  <h5 id="warning">WARNING</h5>

  <p>This tutorial was based on LLVM version 3.1. It does not have support for the recent versions of LLVM.</p>
</blockquote>

<p>For this reason, I decided to use the LLVM version 8.0 after making a few changes in the codebase.
This <a href="https://github.com/P2Tree/LLVM_for_cpu0">repository</a> has the code which supports the LLVM version 8.0</p>

<h5 id="building-the-backend">Building the backend</h5>

<ol>
  <li>
    <p>Build the <a href="https://github.com/llvm/llvm-project">LLVM version 8.0</a></p>
  </li>
  <li>
    <p>Clone <a href="https://github.com/P2Tree/LLVM_for_cpu0">this</a> repository.</p>
  </li>
  <li>
    <p>Run the following commands:</p>

    <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">cmake</span> <span class="nt">-G</span> <span class="s2">"Unix Makefiles"</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="nt">Debug</span> <span class="nc">..</span><span class="o">/</span><span class="nt">llvm</span>
<span class="nt">ninja</span>
</code></pre></div>    </div>
    <p>or just to build the Cpu0 target, run</p>

    <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">cmake</span> <span class="nt">-G</span> <span class="s2">"Unix Makefiles"</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="nt">Debug</span> <span class="nt">-DLLVM_TARGETS_TO_BUILD</span><span class="o">=</span><span class="nt">Cpu0</span> <span class="nc">..</span><span class="o">/</span><span class="nt">llvm</span>
<span class="nt">ninja</span>
</code></pre></div>    </div>
  </li>
  <li>Then run
    <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">cmake</span> <span class="nt">-DCMAKE_CXX_COMPILER</span><span class="o">=</span><span class="nt">clang</span><span class="o">++</span> <span class="nt">-DCMAKE_C_COMPILER</span><span class="o">=</span><span class="nt">clang</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="nt">Debug</span> <span class="nt">-G</span> <span class="s2">"Ninja"</span> <span class="nc">..</span><span class="o">/</span><span class="nt">llvm</span>
<span class="nt">ninja</span>
</code></pre></div>    </div>
  </li>
  <li>Followed by
    <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">build</span><span class="o">/</span><span class="nt">bin</span><span class="o">/</span><span class="nt">llc</span> <span class="nt">--version</span>
</code></pre></div>    </div>

    <blockquote class="block-tip">
      <h5 id="tip">TIP</h5>

      <p>Remember to invoke the llc that we just built, not the system llc.
You can check which llc is being used by running <code class="language-plaintext highlighter-rouge">which llc</code>.
Source the built compiler path</p>
    </blockquote>
  </li>
  <li>Run these commands
    <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="na">export</span><span class="err"> </span><span class="na">PATH</span><span class="err">=&lt;</span><span class="na">path</span><span class="err">&gt;</span><span class="p">:</span><span class="nv">$PATH</span> 
  <span class="n">export</span> <span class="n">LIBRARY_PATH</span><span class="o">=&lt;</span><span class="n">path</span><span class="o">&gt;:</span><span class="nv">$LIBRARY_PATH</span>
  <span class="n">export</span> <span class="n">LD_LIBRARY_PATH</span><span class="o">=&lt;</span><span class="n">path</span><span class="o">&gt;:</span><span class="nv">$LD_LIBRARY_PATH</span>
</code></pre></div>    </div>
  </li>
  <li>Try running some test cases/examples
    <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">build</span><span class="o">/</span><span class="nt">bin</span><span class="o">/</span><span class="nt">clang</span> <span class="nt">-target</span> <span class="nt">x86_64-unknown-linux-gnu</span> <span class="nt">-c</span> <span class="nt">example</span><span class="nc">.c</span> <span class="nt">-S</span> <span class="nt">-emit-llvm</span> <span class="nt">-o</span> <span class="nt">example</span><span class="nc">.ll</span>
<span class="nt">build</span><span class="o">/</span><span class="nt">bin</span><span class="o">/</span><span class="nt">llc</span> <span class="nt">-march</span><span class="o">=</span><span class="nt">cpu0</span> <span class="nt">-mcpu</span><span class="o">=</span><span class="nt">cpu032I</span> <span class="nt">-relocation-model</span><span class="o">=</span><span class="nt">pic</span> <span class="nt">-filetype</span><span class="o">=</span><span class="nt">asm</span> <span class="nt">example</span><span class="nc">.ll</span> <span class="nt">-o</span> <span class="nt">-</span>
</code></pre></div>    </div>
  </li>
</ol>

<h5 id="my-week-2-progress">My Week 2 progress</h5>

<p>During the second week while building the Cpu0 backend in LLVM, I encountered some challenges related to the compatibility of LLVM versions. Here’s a breakdown of my progress and the solutions I found:</p>

<ul>
  <li>
    <p>Attempt: LLVM Version 12
In the beginning, I attempted to build the Cpu0 backend using LLVM version 12. However, I discovered that the Cpu0 backend was not supported in this version. Despite my efforts to modify the LLVM source code, it became clear that the necessary components for the Cpu0 backend were not present.</p>

    <p>Solution 1:
Realizing that version 12 did not support the Cpu0 backend, I decided to explore earlier versions of LLVM to find the desired compatibility.</p>
  </li>
  <li>
    <p>Attempt 2: LLVM Version 10
Next, I tried building the Cpu0 backend using LLVM version 10. Unfortunately, I encountered the same issue as with version 12.</p>

    <p>Solution 2:
Undeterred, I turned to the open-source community to find a solution. After some research, I came across a <a href="https://github.com/P2Tree/LLVM_for_cpu0">repository</a> that contained an unofficial version of the Cpu0 backend for LLVM 8.</p>
  </li>
  <li>
    <p>Attempt 3: LLVM Version 8
Using the GitHub repository as a reference, I started building the Cpu0 backend in LLVM version 8. This involved downloading the LLVM 8 source code and incorporating the necessary files from the repository.</p>

    <p>Solution 3:
By following the instructions provided in the GitHub repository, I successfully built the Cpu0 backend in LLVM version 8.</p>
  </li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[Week 2]]></summary></entry><entry><title type="html">Flashing the Beaglebone black and learning about the pru assembly</title><link href="https://khushi-balia.github.io/blog/2023/week-1/" rel="alternate" type="text/html" title="Flashing the Beaglebone black and learning about the pru assembly" /><published>2023-06-05T19:53:00+00:00</published><updated>2023-06-05T19:53:00+00:00</updated><id>https://khushi-balia.github.io/blog/2023/week-1</id><content type="html" xml:base="https://khushi-balia.github.io/blog/2023/week-1/"><![CDATA[<p>The BeagleBone Black is a versatile single-board computer that opens up a world of possibilities for development projects. In this blog, I will guide you through the process of setting up the BeagleBone Black for development purposes and share my progress from the first week of exploration. Let’s dive in!</p>

<h5 id="setting-up-the-beaglebone-black">Setting Up the BeagleBone Black</h5>

<ol>
  <li>Download the non-flasher recommended debian image from the <a href="https://beagleboard.org/latest-images">beagleboard website</a>.</li>
</ol>

<blockquote class="block-warning">
  <h5 id="warning">WARNING</h5>

  <p>Do not use a “Flasher” image, which can be identified by sequential blinkning of the leds generally.</p>
</blockquote>

<ol>
  <li>
    <p>Flash the Debian image to the microSD card using image writing software <a href="https://etcher.balena.io/">Balena Etcher</a></p>
  </li>
  <li>
    <p>Insert the microSD card into the BeagleBone Black’s card slot. Connect the power supply to the board and wait for it to boot up.</p>
  </li>
  <li>
    <p>The board will power down once the flashing is over.</p>
  </li>
</ol>

<h5 id="setting-up-the-network">Setting up the network</h5>

<ol>
  <li>
    <p>Connect the Board to your host using USB</p>
  </li>
  <li>
    <p>Access the BeagleBone Black by opening a terminal or command prompt and establish an SSH connection to the BeagleBone Black using this <a href="https://gist.github.com/pdp7/d2711b5ff1fbb000240bd8337b859412">script</a></p>
  </li>
  <li>
    <p>The default password is: temppwd</p>
  </li>
</ol>

<h5 id="my-week-1-progress">My Week 1 progress</h5>

<p>During the first week of exploration with the BeagleBone Black, I focused on familiarizing myself with the board and implementing basic examples.</p>

<ul>
  <li>Basic PRU Examples.</li>
</ul>

<p>I flashed some basic examples from the <a href="https://beagleboard.org/static/prucookbook/">PRU Cookbook</a> onto the PRU cores.</p>

<ul>
  <li><a href="https://github.com/dinuxbg/pru-gcc-examples">LED Blinking</a> using PRU-GCC</li>
</ul>

<p>Its the “hello world” example of the embedded world. Both PRU cores of a Beaglebone Black are started to toggle GPIOs. PRU0 core is programmed in C, while the firmware for PRU1 core is written in assembler.</p>

<ul>
  <li>Learning PRU Assembly</li>
</ul>

<p>I dedicated time to learn about PRU assembly, which involved understanding the syntax, instructions, and registers.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Week 1]]></summary></entry><entry><title type="html">Weekly meets and targets</title><link href="https://khushi-balia.github.io/blog/2023/mom-target/" rel="alternate" type="text/html" title="Weekly meets and targets" /><published>2023-06-01T19:53:00+00:00</published><updated>2023-06-01T19:53:00+00:00</updated><id>https://khushi-balia.github.io/blog/2023/mom-target</id><content type="html" xml:base="https://khushi-balia.github.io/blog/2023/mom-target/"><![CDATA[<p>This blog will be updates Bi-weekly.</p>

<h4 id="week-1-and-2">WEEK 1 and 2</h4>

<h5 id="mom---27th-may-2023">MOM - 27th May, 2023</h5>

<ul>
  <li>
    <p>Discussed the scope and implementation of the project</p>
  </li>
  <li>Set targets for Week 1
    <ol>
      <li>Go through the PRU Assembly, compile some examples using pru-gcc</li>
      <li>Refer the Cpu0 backend, going through the codebase and implementation</li>
      <li>Read the PRU section of the reference manual, and understand more about it</li>
    </ol>
  </li>
  <li>
    <p>Suggestion given : Look for a way to take care of the special functions in the language, like gpio pins configuration, debugging functionality and so on</p>
  </li>
  <li>
    <p>Final goal : Upstreaming the backend</p>
  </li>
  <li>References shared:
<a href="https://mythopoeic.org/BBB-PRU/am335xPruReferenceGuide.pdf">https://mythopoeic.org/BBB-PRU/am335xPruReferenceGuide.pdf</a>
<a href="https://www.ti.com/lit/ug/spruh73q/spruh73q.pdf">https://www.ti.com/lit/ug/spruh73q/spruh73q.pdf</a></li>
</ul>

<h4 id="week-3-and-4">WEEK 3 and 4</h4>

<h5 id="mom---10th-june-2023">MOM - 10th June, 2023</h5>

<ul>
  <li>
    <p>Discussed some PRU instructions and registers</p>
  </li>
  <li>Set target for Week 2
    <ol>
      <li>Modify the existing implementation of PRU Backend to support the latest LLVM version 16</li>
      <li>Write the registerinfo.td for PRU</li>
      <li>Write the instrinfo.td for PRU</li>
    </ol>
  </li>
  <li>References shared:
<a href="https://llvm.org/docs/TableGen/ProgRef.html">https://llvm.org/docs/TableGen/ProgRef.html</a>
<a href="https://www.ti.com/lit/SPRUIJ2">https://www.ti.com/lit/SPRUIJ2</a>
<a href="https://mythopoeic.org/BBB-PRU/am335xPruReferenceGuide.pdf">https://mythopoeic.org/BBB-PRU/am335xPruReferenceGuide.pdf</a>
<a href="https://gcc.gnu.org/legacy-ml/gcc-patches/2018-06/msg00775.html">https://gcc.gnu.org/legacy-ml/gcc-patches/2018-06/msg00775.html</a>
<a href="https://github.com/bryant/llvm-pru">https://github.com/bryant/llvm-pru</a></li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[Bi-weekly meets]]></summary></entry></feed>