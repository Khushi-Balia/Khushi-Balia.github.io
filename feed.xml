<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://khushi-balia.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://khushi-balia.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-06-20T01:42:50+05:30</updated><id>https://khushi-balia.github.io/feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">Implementing the Cpu0 Backend</title><link href="https://khushi-balia.github.io/blog/2023/week-2/" rel="alternate" type="text/html" title="Implementing the Cpu0 Backend"/><published>2023-06-15T01:23:00+05:30</published><updated>2023-06-15T01:23:00+05:30</updated><id>https://khushi-balia.github.io/blog/2023/week-2</id><content type="html" xml:base="https://khushi-balia.github.io/blog/2023/week-2/"><![CDATA[<p>LLVM is a widely used open-source compiler infrastructure that provides a set of modular and reusable compiler and toolchain technologies. One of the key strengths of LLVM is its extensibility, allowing developers to add support for new architectures by building backend targets. In this blog, we will walk you through the process of building the Cpu0 backend in LLVM, enabling you to generate code for the Cpu0 architecture. Let’s get started!</p> <h5 id="the-cpu0-backend">The Cpu0 Backend</h5> <p>Cpu0 is a 32-bit architecture. This is the reference of the Cpu0 backend in LLVM <a href="https://jonathan2251.github.io/lbd/llvmstructure.html">Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</a></p> <blockquote class="block-warning"> <h5 id="warning">WARNING</h5> <p>This tutorial was based on LLVM version 3.1. It does not have support for the recent versions of LLVM.</p> </blockquote> <p>For this reason, I decided to use the LLVM version 8.0 after making a few changes in the codebase. This <a href="https://github.com/P2Tree/LLVM_for_cpu0">repository</a> has the code which supports the LLVM version 8.0</p> <h5 id="building-the-backend">Building the backend</h5> <ol> <li> <p>Build the <a href="https://github.com/llvm/llvm-project">LLVM version 8.0</a></p> </li> <li> <p>Clone <a href="https://github.com/P2Tree/LLVM_for_cpu0">this</a> repository.</p> </li> <li> <p>Run the following commands:</p> <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">cmake</span> <span class="nt">-G</span> <span class="s2">"Unix Makefiles"</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="nt">Debug</span> <span class="nc">..</span><span class="o">/</span><span class="nt">llvm</span>
<span class="nt">ninja</span>
</code></pre></div> </div> <p>or just to build the Cpu0 target, run</p> <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">cmake</span> <span class="nt">-G</span> <span class="s2">"Unix Makefiles"</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="nt">Debug</span> <span class="nt">-DLLVM_TARGETS_TO_BUILD</span><span class="o">=</span><span class="nt">Cpu0</span> <span class="nc">..</span><span class="o">/</span><span class="nt">llvm</span>
<span class="nt">ninja</span>
</code></pre></div> </div> </li> <li>Then run <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">cmake</span> <span class="nt">-DCMAKE_CXX_COMPILER</span><span class="o">=</span><span class="nt">clang</span><span class="o">++</span> <span class="nt">-DCMAKE_C_COMPILER</span><span class="o">=</span><span class="nt">clang</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="nt">Debug</span> <span class="nt">-G</span> <span class="s2">"Ninja"</span> <span class="nc">..</span><span class="o">/</span><span class="nt">llvm</span>
<span class="nt">ninja</span>
</code></pre></div> </div> </li> <li>Followed by <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">build</span><span class="o">/</span><span class="nt">bin</span><span class="o">/</span><span class="nt">llc</span> <span class="nt">--version</span>
</code></pre></div> </div> <blockquote class="block-tip"> <h5 id="tip">TIP</h5> <p>Remember to invoke the llc that we just built, not the system llc. You can check which llc is being used by running <code class="language-plaintext highlighter-rouge">which llc</code>. Source the built compiler path</p> </blockquote> </li> <li>Run these commands <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="na">export</span><span class="err"> </span><span class="na">PATH</span><span class="err">=&lt;</span><span class="na">path</span><span class="err">&gt;</span><span class="p">:</span><span class="nv">$PATH</span> 
  <span class="n">export</span> <span class="n">LIBRARY_PATH</span><span class="o">=&lt;</span><span class="n">path</span><span class="o">&gt;:</span><span class="nv">$LIBRARY_PATH</span>
  <span class="n">export</span> <span class="n">LD_LIBRARY_PATH</span><span class="o">=&lt;</span><span class="n">path</span><span class="o">&gt;:</span><span class="nv">$LD_LIBRARY_PATH</span>
</code></pre></div> </div> </li> <li>Try running some test cases/examples <div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">build</span><span class="o">/</span><span class="nt">bin</span><span class="o">/</span><span class="nt">clang</span> <span class="nt">-target</span> <span class="nt">x86_64-unknown-linux-gnu</span> <span class="nt">-c</span> <span class="nt">example</span><span class="nc">.c</span> <span class="nt">-S</span> <span class="nt">-emit-llvm</span> <span class="nt">-o</span> <span class="nt">example</span><span class="nc">.ll</span>
<span class="nt">build</span><span class="o">/</span><span class="nt">bin</span><span class="o">/</span><span class="nt">llc</span> <span class="nt">-march</span><span class="o">=</span><span class="nt">cpu0</span> <span class="nt">-mcpu</span><span class="o">=</span><span class="nt">cpu032I</span> <span class="nt">-relocation-model</span><span class="o">=</span><span class="nt">pic</span> <span class="nt">-filetype</span><span class="o">=</span><span class="nt">asm</span> <span class="nt">example</span><span class="nc">.ll</span> <span class="nt">-o</span> <span class="nt">-</span>
</code></pre></div> </div> </li> </ol> <h5 id="my-week-2-progress">My Week 2 progress</h5> <p>During the second week while building the Cpu0 backend in LLVM, I encountered some challenges related to the compatibility of LLVM versions. Here’s a breakdown of my progress and the solutions I found:</p> <ul> <li> <p>Attempt: LLVM Version 12 In the beginning, I attempted to build the Cpu0 backend using LLVM version 12. However, I discovered that the Cpu0 backend was not supported in this version. Despite my efforts to modify the LLVM source code, it became clear that the necessary components for the Cpu0 backend were not present.</p> <p>Solution 1: Realizing that version 12 did not support the Cpu0 backend, I decided to explore earlier versions of LLVM to find the desired compatibility.</p> </li> <li> <p>Attempt 2: LLVM Version 10 Next, I tried building the Cpu0 backend using LLVM version 10. Unfortunately, I encountered the same issue as with version 12.</p> <p>Solution 2: Undeterred, I turned to the open-source community to find a solution. After some research, I came across a <a href="https://github.com/P2Tree/LLVM_for_cpu0">repository</a> that contained an unofficial version of the Cpu0 backend for LLVM 8.</p> </li> <li> <p>Attempt 3: LLVM Version 8 Using the GitHub repository as a reference, I started building the Cpu0 backend in LLVM version 8. This involved downloading the LLVM 8 source code and incorporating the necessary files from the repository.</p> <p>Solution 3: By following the instructions provided in the GitHub repository, I successfully built the Cpu0 backend in LLVM version 8 and ran some examples.</p> </li> </ul>]]></content><author><name></name></author><summary type="html"><![CDATA[Week 2]]></summary></entry><entry><title type="html">Flashing the Beaglebone black and learning about the pru assembly</title><link href="https://khushi-balia.github.io/blog/2023/week-1/" rel="alternate" type="text/html" title="Flashing the Beaglebone black and learning about the pru assembly"/><published>2023-06-06T01:23:00+05:30</published><updated>2023-06-06T01:23:00+05:30</updated><id>https://khushi-balia.github.io/blog/2023/week-1</id><content type="html" xml:base="https://khushi-balia.github.io/blog/2023/week-1/"><![CDATA[<p>The BeagleBone Black is a versatile single-board computer that opens up a world of possibilities for development projects. In this blog, I will guide you through the process of setting up the BeagleBone Black for development purposes and share my progress from the first week of exploration. Let’s dive in!</p> <h5 id="setting-up-the-beaglebone-black">Setting Up the BeagleBone Black</h5> <ol> <li>Download the non-flasher recommended debian image from the <a href="https://beagleboard.org/latest-images">beagleboard website</a>.</li> </ol> <blockquote class="block-warning"> <h5 id="warning">WARNING</h5> <p>Do not use a “Flasher” image, which can be identified by sequential blinkning of the leds generally.</p> </blockquote> <ol> <li> <p>Flash the Debian image to the microSD card using image writing software <a href="https://etcher.balena.io/">Balena Etcher</a></p> </li> <li> <p>Insert the microSD card into the BeagleBone Black’s card slot. Connect the power supply to the board and wait for it to boot up.</p> </li> <li> <p>The board will power down once the flashing is over.</p> </li> </ol> <h5 id="setting-up-the-network">Setting up the network</h5> <ol> <li> <p>Connect the Board to your host using USB</p> </li> <li> <p>Access the BeagleBone Black by opening a terminal or command prompt and establish an SSH connection to the BeagleBone Black using this <a href="https://gist.github.com/pdp7/d2711b5ff1fbb000240bd8337b859412">script</a></p> </li> <li> <p>The default password is: temppwd</p> </li> </ol> <h5 id="my-week-1-progress">My Week 1 progress</h5> <p>During the first week of exploration with the BeagleBone Black, I focused on familiarizing myself with the board and implementing basic examples.</p> <ul> <li>Basic PRU Examples.</li> </ul> <p>I flashed some basic examples from the <a href="https://beagleboard.org/static/prucookbook/">PRU Cookbook</a> onto the PRU cores.</p> <ul> <li><a href="https://github.com/dinuxbg/pru-gcc-examples">LED Blinking</a> using PRU-GCC</li> </ul> <p>Its the “hello world” example of the embedded world. Both PRU cores of a Beaglebone Black are started to toggle GPIOs. PRU0 core is programmed in C, while the firmware for PRU1 core is written in assembler.</p> <ul> <li>Learning PRU Assembly</li> </ul> <p>I dedicated time to learn about PRU assembly, which involved understanding the syntax, instructions, and registers.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Week 1]]></summary></entry><entry><title type="html">Weekly meets and targets</title><link href="https://khushi-balia.github.io/blog/2023/mom-target/" rel="alternate" type="text/html" title="Weekly meets and targets"/><published>2023-06-02T01:23:00+05:30</published><updated>2023-06-02T01:23:00+05:30</updated><id>https://khushi-balia.github.io/blog/2023/mom-target</id><content type="html" xml:base="https://khushi-balia.github.io/blog/2023/mom-target/"><![CDATA[<p>This blog will be updates Bi-weekly.</p> <h4 id="week-1-and-2">WEEK 1 and 2</h4> <h5 id="mom---27th-may-2023">MOM - 27th May, 2023</h5> <ul> <li> <p>Discussed the scope and implementation of the project</p> </li> <li>Set targets for Week 1 <ol> <li>Go through the PRU Assembly, compile some examples using pru-gcc</li> <li>Refer the Cpu0 backend, going through the codebase and implementation</li> <li>Read the PRU section of the reference manual, and understand more about it</li> </ol> </li> <li> <p>Suggestion given : Look for a way to take care of the special functions in the language, like gpio pins configuration, debugging functionality and so on</p> </li> <li> <p>Final goal : Upstreaming the backend</p> </li> <li>References shared: <a href="https://mythopoeic.org/BBB-PRU/am335xPruReferenceGuide.pdf">https://mythopoeic.org/BBB-PRU/am335xPruReferenceGuide.pdf</a> <a href="https://www.ti.com/lit/ug/spruh73q/spruh73q.pdf">https://www.ti.com/lit/ug/spruh73q/spruh73q.pdf</a></li> </ul> <h4 id="week-3-and-4">WEEK 3 and 4</h4> <h5 id="mom---10th-june-2023">MOM - 10th June, 2023</h5> <ul> <li> <p>Discussed some PRU instructions and registers</p> </li> <li>Set target for Week 2 <ol> <li>Modify the existing implementation of PRU Backend to support the latest LLVM version 16</li> <li>Write the registerinfo.td for PRU</li> <li>Write the instrinfo.td for PRU</li> </ol> </li> <li>References shared: <a href="https://llvm.org/docs/TableGen/ProgRef.html">https://llvm.org/docs/TableGen/ProgRef.html</a> <a href="https://www.ti.com/lit/SPRUIJ2">https://www.ti.com/lit/SPRUIJ2</a> <a href="https://mythopoeic.org/BBB-PRU/am335xPruReferenceGuide.pdf">https://mythopoeic.org/BBB-PRU/am335xPruReferenceGuide.pdf</a> <a href="https://gcc.gnu.org/legacy-ml/gcc-patches/2018-06/msg00775.html">https://gcc.gnu.org/legacy-ml/gcc-patches/2018-06/msg00775.html</a> <a href="https://github.com/bryant/llvm-pru">https://github.com/bryant/llvm-pru</a></li> </ul>]]></content><author><name></name></author><summary type="html"><![CDATA[Bi-weekly meets]]></summary></entry></feed>